---
author: willis
date: 2019-02-25 01:03
---

##  Dubbo的踩坑过程
### 踩坑点
```java
@Reference
```
注解注释的字段无法注入实例，字段始终为null

### 项目配置如下
- 开源框架
springboot2.1.3 + dubbo2.6.1 + apollo 
- 配置文件路径：resources/applicaionContext-dubbo.xml
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
       xmlns="http://www.springframework.org/schema/beans"
       profile="dubbo"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd
        ">
    <dubbo:application name="xxx"/>
    <dubbo:registry protocol="zookeeper" address="zookeeper://ip:port"/>
    <dubbo:protocol name="dubbo" port="6666" server="netty"/>
    <dubbo:consumer check="false" filter="traceIdConsumer,default" timeout="5000" retries="0"/>
    <dubbo:provider filter="traceIdProvider,default,dubboxLogFilter"/>
    <!-- dubbo 扫描包路径-->
    <dubbo:annotation package="com.xxx"></dubbo:annotation>
    <!-- consumer -->
</beans>
```
- 启动类
``` java
@ImportResource(locations = {"classpath:applicationContext-*.xml"})
@SpringBootApplication(scanBasePackages = "com.xxx")
public class Application {
    private static final String APPLICATION_NAME = "xxx";
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        ConfigurableApplicationContext context = app.run(args);
        Runtime.getRuntime().addShutdownHook(new Thread(context::close));
    }
}
```
- 逻辑引用
```java
@Component
@Slf4j
public class PoiRegionInvoker {
	/**
	 * dubbo引用
	 */
    @Reference(version = "0.1.0")
    private FindRegionService findRegionService;
    // 下面代码略啦
}
```
### 问题排除过程
- 排除dubbo的扫描路径配置有问题，检查发现xml配置无误
- 排除生产者服务挂掉的问题，因为启动是连接zk正常

最后难以找出问题出现在哪里，只要跟进dubbo客户端运行源码进行分析。

### Dubbo客户端注解生效原理
- 先看@Reference的，@Service后面更新
首先，Dubbo自己定义了一套NamespaceHandlerSupport实现，参见Dubbo客户端jar包下的spring.handlers 文件，如图
![]({{ site.baseurl }}/images/2019-10-14/spring-handler2-1.png)
得到类DubboNamespaceHandler，查看其源码
```java
public class DubboNamespaceHandler extends NamespaceHandlerSupport {

    static {
        Version.checkDuplicate(DubboNamespaceHandler.class);
    }

    public void init() {
        registerBeanDefinitionParser("application", new DubboBeanDefinitionParser(ApplicationConfig.class, true));
        registerBeanDefinitionParser("module", new DubboBeanDefinitionParser(ModuleConfig.class, true));
        registerBeanDefinitionParser("registry", new DubboBeanDefinitionParser(RegistryConfig.class, true));
        registerBeanDefinitionParser("monitor", new DubboBeanDefinitionParser(MonitorConfig.class, true));
        registerBeanDefinitionParser("provider", new DubboBeanDefinitionParser(ProviderConfig.class, true));
        registerBeanDefinitionParser("consumer", new DubboBeanDefinitionParser(ConsumerConfig.class, true));
        registerBeanDefinitionParser("protocol", new DubboBeanDefinitionParser(ProtocolConfig.class, true));
        registerBeanDefinitionParser("service", new DubboBeanDefinitionParser(ServiceBean.class, true));
        registerBeanDefinitionParser("reference", new DubboBeanDefinitionParser(ReferenceBean.class, false));
        registerBeanDefinitionParser("annotation", new AnnotationBeanDefinitionParser());
    }
}
```
最后一行，就是注册dubbo注解解释器（AnnotationBeanDefinitionParser）到spring的容器中,在spring的parses中缓存起来。
找到NamespaceHandlerSupport类的parse方法，如下
![]({{ site.baseurl }}/images/2019-10-14/source-code-1.png)
进入到DubboBeanDefinitionParser的parse方法,会初始化dubbo一些配置bean的def，封装成RootBeandefinition到spring容器中。
![]({{ site.baseurl }}/images/2019-10-14/source-code-2.png)
同样是图
![]({{ site.baseurl }}/images/2019-10-14/source-code-1.png)
如果BeanDefinitionParser 是上面注册的AnnotationBeanDefinitionParser，就会进入到
org.springframework.beans.factory.xml.AbstractBeanDefinitionParser类的parse()方法，找到主要方法parseInternal()
![]({{ site.baseurl }}/images/2019-10-14/source-code-3.png)
在parseInternal方法中，找到重要的一样代码
```java
doParse(element, parserContext, builder)
```
当前类AbstractBeanDefinitionParser此时实现类正是 AnnotationBeanDefinitionParser，查看
AnnotationBeanDefinitionParser的doParse()方法，代码如下
```java
protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		// 解析扫描的包路径
        String packageToScan = element.getAttribute("package");

        String[] packagesToScan = trimArrayElements(commaDelimitedListToStringArray(packageToScan));

        builder.addConstructorArgValue(packagesToScan);

        builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

        // Registers ReferenceAnnotationBeanPostProcessor
 // 注册ReferenceAnnotationBeanPostProcessor，这个processor的作用就是用来扫描springbean中含有Reference注解的字段并进行赋值处理的处理器
 		registerReferenceAnnotationBeanPostProcessor(parserContext.getRegistry());
}
private void registerReferenceAnnotationBeanPostProcessor(BeanDefinitionRegistry registry) {

        // Register @Reference Annotation Bean Processor
        BeanRegistrar.registerInfrastructureBean(registry,
                ReferenceAnnotationBeanPostProcessor.BEAN_NAME, ReferenceAnnotationBeanPostProcessor.class);

    }
```
- 最后，找到ReferenceAnnotationBeanPostProcessor源码，发现其实现了MergedBeanDefinitionPostProcessor接口，该接口是spring的beanfactory的执行doCreateBean方法，根据beandefinition创建bean实例前回调的接口。

主要源码
```java
private List<InjectionMetadata.InjectedElement> findFieldReferenceMetadata(final Class<?> beanClass) {

        final List<InjectionMetadata.InjectedElement> elements = new LinkedList<InjectionMetadata.InjectedElement>();

        ReflectionUtils.doWithFields(beanClass, new ReflectionUtils.FieldCallback() {
            @Override
            public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException {

                Reference reference = getAnnotation(field, Reference.class);

                if (reference != null) {

                    if (Modifier.isStatic(field.getModifiers())) {
                        if (logger.isWarnEnabled()) {
                            logger.warn("@Reference annotation is not supported on static fields: " + field);
                        }
                        return;
                    }

                    elements.add(new ReferenceFieldElement(field, reference));
                }

            }
        });

        return elements;

    }
    
    @Override
    public PropertyValues postProcessPropertyValues(
            PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeanCreationException {

        InjectionMetadata metadata = findReferenceMetadata(beanName, bean.getClass(), pvs);
        try {
            metadata.inject(bean, beanName, pvs);
        } catch (BeanCreationException ex) {
            throw ex;
        } catch (Throwable ex) {
            throw new BeanCreationException(beanName, "Injection of @Reference dependencies failed", ex);
        }
        return pvs;
    }
```
findFieldReferenceMetadata() 用于取出所有使用Reference注解修饰的字段。
postProcessPropertyValues()是对InstantiationAwareBeanPostProcessor接口的postProcessPropertyValues()方法的实现，会在Beanfactory  docreateBean 的时候创建