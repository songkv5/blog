---
author: 行走的火龙果
date: 2020-04-18 23:24
---

# 分布式系统的一致性协议
>在分布式系统中，每一个及其结点虽然都能明确的知道自己在进行实务操作过程中的结果是成功或失败，但却无法直接获得到其他分布式结点的操作结果。
>当一个事务操作需要跨越多个分布式结点的时候， 为了保持事务处理的ACID特性，就需要引入一个而成为协调者（Cordinator）的组件来统一调度所有分布式结点的执行逻辑，这些被调度的恩不是结点则被称为参与者（Participant）。
>协调者负责调度参与者的行为，病最终决定这些参与者是否要把事务真正的提交。
## 一、 2PC（Two-Phase Commit）
>二阶段提交被认为是一种一致性协议，用来保证分布式系统数据的一致性，目前，绝大部分的关系型数据库都是采用二阶段提交协议来完成分布式事务处理，利用该协议能够非常方便的完成所有分布式事务参与者的协调，统一决定失误的提交或回滚从而能够有效的保证分布式数据一致性

### 协议说明
#### 阶段一：提交事务请求
也称为“投票阶段”
- 1)事务询问
>协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。

- 2)执行事务
>个参与者节点执行事务操作，并将undo和redo信息记入事务日志中

- 3)各参与者向协调者反馈事务询问的响应
>各参与者成功执行了实务操作，那么久反馈给协调者Yes响应，表示事务可以执行；
>如果参照语者没有成功执行事务，那么久反馈个协调者No响应，表示事务不可以执行

#### 阶段二：执行事务提交
**假如协调者从所有的参与者获得的反馈都是yes响应，那么就会执行事务提交**
*事务提交有两种可能：提交和中断*
**_1、执行事务提交_**

- 1)发送提交请求
>协调者向所有参与者结点发出commit请求

- 2)事务提交
>参与者接收到commit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源

- 3)反馈事务提交结果
>参与者在完成事务提交之后，向协调者发送ack消息

- 4)完成事务 
>协调者接收到所有参与者反馈的ack消息后，完成事务

执行事务提交的过程，如图
![2PC-事务提交]({{ site.baseurl }}/images/2020-04-18/2PC-commit.png)

**_2、中断事务_**

>假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务

- 1)发送回滚请求
>协调者向所有参与者结点发出Rollback请求

- 2)事务回滚
>参与者接收到rollback请求后，会利用其在第一阶段中记录的undo信息来执行事务回滚操作，并在完成回滚之后释放整个事务执行期间占用的资源。

- 3)反馈失误回滚结果
>参与者在完成事务回滚之后，向协调者发送ack消息

- 4)中断事务
>协调者接收到所有参与者反馈的ack消息后，完成事务中断

中断事务的过程，如图
![2PC事务中断]({{ site.baseurl }}/images/2020-04-18/2PC-rollback.png)

### 2PC优缺点

优点：原理简单、实现方便
缺点：同步阻塞、单点问题、脑裂、太过保守

**同步阻塞**
>【所有参与该事务操作】的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。

**单点问题**
一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，无法继续完成事务操作。

**数据不一致**
在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有参与者发送commit请求之后，发生了局部网络异常或者是协调者在尚未发送完commit请求之前自身发生了奔溃，导致最终只有部分参与者收到了commit请求。于是，这部分收到了commit请求的参与者就会进行事务的提交，而其他没有收到commit请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致现象。
[脑裂](https://www.cnblogs.com/nicerblog/p/11232531.html)

**太过保守**
>如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法活的到所有参与者的响应信息，这时协调者只能依照其自身的超时机制来判断是否需要中断事务。二阶段提交协议没有涉及较为完善的绒促机制，任意一个结点失败都会导致整个事务的失败


## 二、3PC（Three-Phase Commit）
>将二阶段提交协议的“提交事务请求”过程一分为二，形成了由【CanCommit、PreCommit】和【do Commit】三个阶段组成的事务处理协议
![3PC]({{ site.baseurl }}/images/2020-04-18/3PC-1.png)

### 协议说明
#### 阶段一：CanCommit
- 1)事务询问
>协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交请求，并开始等待各参与者的响应。

- 2)各参与者向协调者反馈事务询问的响应
>参与者在接收到来自协调者的canCommit请求后，正常情况下，如果其自身认为可以顺利执行失误，那么会反馈Yes响应，并进入预备状态，否则反馈No响应

#### 阶段二：PreCommit
>协调者根据各参与者的反馈情况来决定是否可以进行事务的PreCommit请求。
*有两种可能：执行事务预提交；中断事务*

_1、执行事务预提交_
>协调者从所有参与者获得的反馈都是Yes
- 1)发送与提交请求
>协调者向所有参与者结点发出preCommit请求，并进入Prepared阶段

- 2)事务预提交
>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中

- 3)各参与者向协调者反馈失误执行的响应
>如果参与者成功执行了事务操作，那么就会反馈给协调者Ack响应，同时等待最终指令：提交（commit）或终止（abort）

_2、中断事务_
>任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务

- 1) 发送中断请求
>协调者向所有参与者结点发出abort请求。
- 2)中断事务
>无论是收到来自协调者的abort请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务


#### 阶段三：doCommit
>该阶段进行真正的事务提交
*有两种可能：执行提交；中断事务*

_1、执行提交_
- 1)发送提交请求
>协调者接收到了所有参与者的Ack响应，那么它将从“预提交”状态转换到“提交”状态，并向所有参与者发送doCommit请求

- 2)事务提交
>参与者收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源

- 3)反馈事务提交结果
>参与者在完成事务提交之后，向协调者发送Ack消息

- 4)完成事务
>协调者接收到所有参与者反馈的Ack响应，完成事务

_2、中断事务_
>协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，就会中断事务

- 1)发送中断请求
>协调者向所有参与者结点发送abort请求

- 2)事务回滚
>参与者收到abort请求后，利用阶段二中记录的undo信息执行回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源

- 3)反馈事务回滚结果
>参与者在完成事务回滚之后，向协调者发送Ack消息

- 4)中断事务
>协调者接收到所有参与者反馈的Ack消息后，中断事务

**注意**：一旦进入阶段三，可能会存在一下两种故障
- 协调者出现问题
- 协调者与参与者的网络出现故障
无论哪种情况，最终都会导致参与者无法及时接收到来自协调者的doCommit或者abort请求，针对这样异常的情况，参与者都会在等待超时之后，继续进行事务的提交。

### 3PC优缺点
- 优点：相较于2PC，3PC提交降低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。
- 缺点：如果参与者接收到preCommit消息后，出现网络分区，此时协调者所在结点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。