---
author: willis
date: 2020-05-10 00:20
---
## 内存模型与线程安全

### 硬件的效率
>处理器与内存交互，如读取数据、存储运算结果等等，这些操作涉及的IO操作是不可避免的。而存储设备与处理器的运算速度有几个数量级的差距，所以，现代计算机都在处理器与内存之间加入了一层尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，运算结束后再从缓存同步会内存之中，这样处理器就无须等待缓慢的内存读写了。

#### 缓存一致性协议
>在多处理器系统中，每个处理器都有自己的高速缓存，他们又共用同一块内存。如果多个处理器的任务都涉及到同一块主内存区域时，可能导致各自的缓存数据不一致。为了解决这个问题，引入了缓存一致性协议。内存、高速缓存、处理器之间的关系如图
![内存、高速缓存、处理器关系]({{ site.baseurl }}/images/2020-05-10/jmm-1.png)

### 线程运行的内存模型（区别于堆、栈、方法区的内存划分方式）
>java中，所有变量都存储在主内存。每个线程还有自己的工作内存。（工作内存可以类比于上面讲到的高速缓存）
>java线程运行时，对变量的操作都是先从主存拷贝到工作内存，然后从对工作内存中的变量副本进行计算，线程不能直接操作主存中的变量。他的模型如下
![线程、工作内存、主存关系]({{ site.baseurl }}/images/2020-05-10/jmm-2.png)

#### java内存交互操作
>- lock（锁定）
>>作用于主存。标志为线程独占
>- unlock（解锁）
>>作用于主存。释放处于锁定状态的变量
>- read（读取）
>>原子操作。作用于主存的变量。将变量从主存传输到工作内存，为后面的load做准备
>- load（载入）
>>原子操作。作用于工作内存的变量，把read操作从主存得到的变量值放入工作内存的变量副本中
>- use（使用）
>>原子操作。作用于工作内存的变量,把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令是会执行这个操作。
>- assign（赋值）
>>原子操作。作用于工作内存的变量,把一个从执行引擎接收到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令是会执行这个操作。
>- store（存储）
>>原子操作。作用于工作内存的变量,把总做内存的中的一个变量的值【传递】到主存，以便随后的write操作使用
>- write（写入）
>>原子操作。作用于主内存的变量，把store操作从工作内存中得到的变量的值放到主存的变量中

#### volatile可见性
>1. 一个变量被volatile修饰后，保证了这个变量对其他线程的可见性
>jvm在工作线程获取变量值得时候，会判断变量是否被volatile修饰，如果被volatile修饰，那么将会从主存中重新取最新值刷新工作内存中的变量值；同理，在工作内存写操作时，如果发现变量被volatile修饰，会立马将变量值从工作内存写到主内存中。
>2. 一个变量被volatile修饰后，会禁止指令重排序的优化
>虚拟机的编译优化可能造成编译器优化，造成一条对应的指令被提前或者滞后执行，加了volatile修饰的变量，与他相关的指令不会出现重新排序，保证指令的执行顺序

### 线程模型
#### 线程的实现
>线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程可以共享进程资源（内存地址、文件io等），又可以独立调度（线程是cpu调度的基本单位）
>**实线线程的三种方式**：
>1. 依靠内核线程
>>内核线程（kernel-level-thread，KLT）是直接有操作系统内核（Kernel）支持的线程。这种线程有内核来完成线程的切换，内核通过调度器（scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情。支持多线程的内核叫做多线程内核（Multi-Threads Kernel）
>>程序一般不会直接去使用内核线程，而是去使用内核线程提供的高级接口-轻量级进程（Light-Weight Process，LWP），这个就是我们通常意义上的线程。每个轻量级进程都由一个内核线程支持，因此，只有先支持内核线程，才能有轻量级进程。参考图
![内核线程]({{ site.baseurl }}/images/2020-05-10/tm-1.png)
>>**轻量级进程的局限性**： 
>>>1. 由于急于内核线程实线，各种线程操作，如创建、西沟及同步，都需要进行系统调用。而系统调用代价相对较高，需要在【用户态】和【内核态】中来回切换
>>>2. 每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如线程栈空间），因此系统支持轻量级进程数量是有限的

>2. 依靠用户线程
>定义。
>>广义来讲，一个线程如果不是内核线程，就可以认为是用户线程。从这个角度来讲，轻量级进程也是用户线程，但是，轻量级进程实现始终依靠内核线程来完成，许多操作都要进行系统调用，效率会受到限制
>>狭义上，用户线程值得是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度【完全在用户态】中完成，不需要内核的帮助，模型如图
>>![用户线程]({{ site.baseurl }}/images/2020-05-10/tm-2.png)
>>**局限性**：使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核资源，所有的线程操作都需要用户程序自己处理。线程的创建、切换、调度都是要考虑的问题，而且操作系统只把处理器资源分配到晋城，诸如“阻塞如何处理”、“多处理器系统如何将线程映射到其他处理器上”这类问题解决起来也异常困难，甚至不可能。java、ruby等语言曾经都用过用户线程，最终又都放弃使用它。

>3. 依靠用户线程+轻量级进程混合
>这种模式下，既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险。这种模型，用户线程与轻量级进程的数量比不确定，n：m的关系
>![用户线程+轻量级进程混合]({{ site.baseurl }}/images/2020-05-10/tm-2.png)

>4. java线程模型
>>对于Sun JDK来说，他的windows版与linux版都是使用1对1的线程模型实现的，一条java线程就映射到一条轻量级进程之中，因为windows和linux系统提供的线程模型就是一对一的

### 线程调度
>线程调度是指系统为线程分配处理器使用权的过程。
>>协同是调度
>>>1. 好处：实线简单，线程要把自己做的事做完才会进行线程切换，切换操作对线程自己是可知的。不存在同步问题。
>>>2. 弊端：线程执行时间不可控制，如果一个线程编写有问题，一直不告诉系统进行线程切换，就会一直阻塞。

>>抢占式调度
>>>每个线程的执行时间由系统来分配，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，java使用的线程调度就是抢占式的。

### 线程状态
>1. 新建（New）：创建后尚未启动的线程

>2. 运行（Runable）：包括操作系统线程状态中的Running和Ready。即线程可能正在执行，也可能正在等待CPU为他分配执行时间

>3. 无限期等待（Waiting）：这种状态的线程不会被分配cpu执行时间，要等待其他线程【显示唤醒】。可以出发该状态的方法
>> LockSupport.park()
>> 没有Timeout的Object.wait()
>> 没有Timeout的Thread.join()
>>>延伸：陷入无限期等待后，线程如何被唤醒？在jvm，jion进来的线程终止时，会检查阻塞在当前线程的其他线程，完成时，执行当前线程的notifyAll方法，被阻塞的线程继续执行。可以参考jdk注解：如图
>>>![threadjdk部分源码]({{ site.baseurl }}/images/2020-05-10/jdk-thread.join-1.png)

>4. 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显示唤醒，过一段时间后他们会由系统自动唤醒。可以触发限期等待的方法：
>>Thread.sleep
>>设置了Timeout参数的Object.wait()方法
>>设置了Timeout参数的Thread.join()方法
>>LockSupport.parkNanos()方法
>>LockSupport.parkUnit()方法

>5. 阻塞（Blocked）：程序等待进入同步区域的时候，线程进入这种状态

>6. 结束（Terminated）：已终止线程的状态