---
author: willis
date: 2020-05-10 00:20
---
## 内存模型与线程安全

### 硬件的效率
>处理器与内存交互，如读取数据、存储运算结果等等，这些操作涉及的IO操作是不可避免的。而存储设备与处理器的运算速度有几个数量级的差距，所以，现代计算机都在处理器与内存之间加入了一层尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能快速进行，运算结束后再从缓存同步会内存之中，这样处理器就无须等待缓慢的内存读写了。

#### 缓存一致性协议
>在多处理器系统中，每个处理器都有自己的高速缓存，他们又共用同一块内存。如果多个处理器的任务都涉及到同一块主内存区域时，可能导致各自的缓存数据不一致。为了解决这个问题，引入了缓存一致性协议。内存、高速缓存、处理器之间的关系如图
![内存、高速缓存、处理器关系]({{ site.baseurl }}/images/2020-05-10/jmm-1.png)

### 线程运行的内存模型（区别于堆、栈、方法区的内存划分方式）
>java中，所有变量都存储在主内存。每个线程还有自己的工作内存。（工作内存可以类比于上面讲到的告诉缓存）
>java线程运行时，对变量的操作都是先从主存拷贝到工作内存，然后从对工作内存中的变量副本进行计算，线程不能直接操作主存中的变量。他的模型如下
![线程、工作内存、主存关系]({{ site.baseurl }}/images/2020-05-10/jmm-2.png)

#### java内存交互操作
>- lock（锁定）
>作用于主存。标志为线程独占
>- unlock（解锁）
>作用于主存。释放处于锁定状态的变量
>- read（读取）
>原子操作。作用于主存的变量。将变量从主存传输到工作内存，为后面的load做准备
>- load（载入）
>原子操作。作用于工作内存的变量，把read操作从主存得到的变量值放入工作内存的变量副本中
>- use（使用）
>原子操作。作用于工作内存的变量,把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令是会执行这个操作。
>- assign（赋值）
>原子操作。作用于工作内存的变量,把一个从执行引擎接收到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令是会执行这个操作。
>- store（存储）
>原子操作。作用于工作内存的变量,把总做内存的中的一个变量的值【传递】到主存，以便随后的write操作使用
>- write（写入）
>原子操作。作用于主内存的变量，把store操作从工作内存中得到的变量的值放到主存的变量中

#### volatile可见性
>1. 一个变量被volatile修饰后，保证了这个变量对其他线程的可见性
>jvm在工作线程获取变量值得时候，会判断变量是否被volatile修饰，如果被volatile修饰，那么将会从主存中重新取最新值刷新工作内存中的变量值；同理，在工作内存写操作时，如果发现变量被volatile修饰，会立马将变量值从工作内存写到主内存中。
>2. 一个变量被volatile修饰后，会禁止指令重排序的优化
>虚拟机的编译优化可能造成编译器优化，造成一条对应的指令被提前或者滞后执行，加了volatile修饰的变量，与他相关的指令不会出现重新排序，保证指令的执行顺序

### 线程模型
#### 线程的实现
未完待续